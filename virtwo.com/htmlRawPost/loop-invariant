<h3 id="post-title">Loop Invariants</h3>

<i id="post-date">2011-12-04 00:00</i>

<p id="post-group">Computers</p>

<p id="post-category">Programming</p>

<div id="post-body" >

	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

	<p>I was wondering the other day, what is the most important part of any code? Many answers came to my mind, functions, pointers etc- but at the end I realized that they are all, but the part of a particular programming language. Then what was there, that was supposed to be common in all the programs. I recalled the definition of a program, and found that loops and condition statements are what guide the logical flow of a program. Indeed loops even surpassed the condition statements. They were like supersets of condition statements. After realizing the importance of the loops in the program, I got worried, what if the loops I have written in my programs were wrong, though they appear right, and who knows that they misbehave at some instance of time? At that juncture, I got a chance to explore about loop-invariants, which present themselves as a powerful methodology to check the correctness of the loops. The best part is, they are free of the programming language, and one can use them in any programming language of choice. I thought of sharing the same with you too, so bashed my experiences with loop-invariants here.</p>

	<p>Well, loop-invariants are the assertions that remain true before, after and during the execution of the loop. Simple! Isn't it! Formally, Loop invariant is a methodology to test the correctness of the loops and hence contribute in verifying the algorithm too, by directly participating in the inductive part of the algorithm. This definition is coupled with the fact that, there may be various ways in which the variables may take up values that we refer to as configuration, but only a particular set of configuration is acceptable in the light of loop invariants, that remain constant throughout the lifecycle of the program. I know, second line onwards, is confusing, but if you are confused, then probably, this is not meant for you. Anyways, highly interested geeks can search for mathematical formulation of loop-invariants, to understand the above formal statement.</p>

	<p>Ok! Let us get back to the basics. What do you write first, loop or the loop-invariant? Don't worry it is not like egg-chicken problem. We have a very simple method; decide upon the responsibility of the loop you want, and then choose the loop-invariant and finally using it write the loop. To start with, decide upon the variable which is going to hold the result after the loop execution ends. Then decide upon the loop guard. Loop guard is nothing but the exit condition for the loop, and that means the condition, whose failure leads to exit from the loop, and this is a must else you will fall into infinite loop iterations. With this stage set, find the condition i.e. make an assertion that will hold before, after and during the execution of the loop. </p>

	<p>Well, I know you may be confused, so let us have a look at an example to make our points clearer, by visiting the factorial function, but in a different manner.</p>
	
	<code>PROBLEM: Find the factorial of a number N.</code>

	<p>Next, we define the precondition as <code>N > 0</code> and postcondition as the <code>RESULT</code> that stores the factorial of the number <code>N</code>. Now, we have to decide the loop-guard and from our knowledge about factorial i.e. <code>N! = N x N-1 x N-2 x N-3 ... 1</code>, we know that we have to do our computation in a non-ascending manner and it will continue till all values greater than <code>1</code> and below <code>N + 1</code> are not multiplied, and stored in <code>RESULT</code>. In simple words inside the loop we are doing multiplication of numbers from <code>N</code> to <code>1</code> and are storing the result i.e. the factorial of the number <code>N</code> in <code>RESULT</code>. One thing that we need to note here is that every iteration of the loop is inductive, and you know it, recall <code>N! = N x (N-1)!</code>. So in iterations of the loop if we go in ascending order, we would be progressively calculating the factorial of some number that will be directly related to the loop's iteration. We can also make the loop go in non-ascending order (the way we were talking earlier, or we generally do), but then feeling the flow of induction may become a bit tricky, so at this stage we will avoid it. Now, we are set to write the code. The explanation is written in comments, in the code.</p>

	<pre class="prettyprint lang-c" data-external-text="code/factorial-1.c" />
	
	<p>So, what is the loop-invariant? Did you see it? Let me tell you, <code>RESULT</code> at any moment stores the factorial of a number. Before the execution starts, it held the <code>1!</code>, after execution it held <code>N!</code> and during the execution <code>i!</code> was stored in it, making the inductive step very clear. If at some point of time, if the loop-invariant would have gone wrong, the factorial would have been miscalculated. In case of non-ascending loop, the loop invariant would have been <code>RESULT = N! / (N-i)!</code>, where <code>i</code> is the iteration number (if you are not clear, think again, and that is why I avoided it). Well, this might not have been the way you were in habit of writing the factorial code, but whatever method you would have been following; recursion, loops etc. everywhere the method we have followed here, is hidden.</p>

	<p>I guess, what does loop-invariant means is clear to you now, so we will move on to another question that is how to identify loop-invariants? Well until and unless you dwell from the country of artificial intelligence, it is very difficult to automatically guess about the loop-invariants i.e. formulate rules for detection of loop-invariants. So we will have a look on how does loop-invariants formally appear in any program, to make their discovery a bit easier.</p>

	<p>We will use Hoare notation, given in 1969, to prove the correctness of the programs. We assume that there exists a logic of form <code>{P} S {Q}</code>, where <code>P</code> & <code>Q</code> are predicates and <code>S</code> is the program, and the statement reads, when <code>P</code> is true, then after the execution of <code>S</code>, <code>Q</code> will be true. With this logic, the loop takes the form: <code>{P} while C do S {Q}</code>, where <code>C</code> is the loop guard.  Here <code>P</code> and <code>Q</code> serve as loop-invariants, namely <code>I</code> & <code>II</code>.</p>

	<p>At this juncture it becomes important to tell you that, we cannot develop a fixed set of rules for invariant detection and discovery and also give you the reason why we cannot do so.  We need a logic to detect the above logic i.e. <code>{P} S {Q}</code> (see we are getting into computer intelligence), to identify the loop-invariants. Sadly, with all the variables in hand (many of which will never become part of loop-invariant), and with the big set of configurations formed by them, it becomes very difficult to verify and check for the invariant (Cook's completeness theorem proves this fact). Well, though it makes it near to impossible to build a perfect loop-invariant finder (read about NP-completeness, to understand the logic behind this statement), it leaves space for guesses, rather good guesses. Anyways, for now, whenever you see a loop, look for the pattern <code>{P} S {Q}</code> and identify the loop-invariants (this is what is practical in most cases).</p>

	<p>Well, though I know, perfect methods do not exist, I'll give you a simple algorithm to find out the loop-invariants (I guess it will work in most of the cases). Before we start, let me tell you one more trick that will make life simpler, do not include any statement that is not dependent on the iteration inside the loop body. Anyways, here goes the algorithm in informal pseducode.</p>

	<pre class="prettyprint" data-external-text="code/loop-invariant.pc" />	

	<p>The last condition is weak and may need to be escaped at times. Next, we make sure that we make three statements of the loop-invariant found, one servers as the predicate <code>{P}</code>, other serves as <code>{Q}</code> and one enters the <code>S</code>, again the last statement is not mandatory. Well, in the way, you may need to reduce some statements into simpler forms. Another thing, in programming practice it may happen that making <code>{P}</code> and <code>{Q}</code> are useless or are contained in the <code>S</code> etc. but you have to realize that, it is different between theory and practice. Lastly, by definition of a statement, we refer to statements that modify a particular variable. I know the last statement will again pose problem, but if you decompose the statements inside the loop into simpler form, in a way that the statements inside the loop are independent and this may be achieved by use of dedicated variables inside the loop. </p> 

	<p>Well we are done. No more on loop-invariants. All this discussion was to give you a feel and make you realize that they exist, when you write the loops. This discussion will also help you verify the correctness of the loops in primitive form and identify simple loop-invariants.</p>

	<p>HAPPY INVARIANCE!</p>
	
</div>